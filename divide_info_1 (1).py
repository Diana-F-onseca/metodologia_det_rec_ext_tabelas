# -*- coding: utf-8 -*-
"""divide_info_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YtZF-FtHIi998pkkzdlbN11lqOD2upQB
"""

import re

class DivideInfo:

    def __init__(self) -> None:
        pass

    def split_string(self,s):
        # A expressão regular abaixo vai encontrar palavras seguidas por algo entre parênteses como um único grupo
        # e também vai capturar palavras isoladas ou outras sequências como outro grupo
        pattern = re.compile(r'\b\w+\s*\([^)]*\)|\w+[%]?')
        return pattern.findall(s)

    def transform_string_to_custom_list(self,input_string):
        # Dividir a string em palavras
        words = input_string.split(' ')

        # Inicializar a lista resultante com 'NB PIECES'
        result_list = ['NB PIECES']

        # Adicionar o restante das palavras individualmente
        result_list.extend(words[2:])

        return result_list

    def transform_string_to_custom_list_preco_venda(self,input_string):
        # Dividir a string em palavras
        words = input_string.split('Preço Venda')

        # Inicializar a lista resultante com 'NB PIECES'
        result_list = ['']

        # Adicionar o restante das palavras individualmente
        result_list.extend(words[2:])

        return result_list

    def transform_string_to_custom_list_Pattern_no(self,texto):
        # Padrão regex para identificar os segmentos
        padrao = re.compile(r'(Pos\.|Pattern no\.|Customer)')
        # Encontrar todos os segmentos que correspondem ao padrão especificado
        segmentos = padrao.findall(texto)
        return segmentos

    def transform_string_to_custom_list_preco_liquido(self,input_string):
        # Dividir a string em palavras
        palavras = input_string.split()

        # Unir as palavras nas suas respectivas categorias
        preco_liquido = palavras[0] + ' ' + palavras[1]
        quantidade_un = palavras[2] + ' ' + palavras[3]
        valor_liquido = palavras[4] + ' ' + palavras[5]

        # Retornar a lista com as categorias divididas
        return [preco_liquido, quantidade_un, valor_liquido]

    def dividir_string_preco_unitario(self,texto):
        # Dividir a string na ocorrência de 'Preço Unitário'
        partes = re.split(r'(Preço Unitário)', texto)

        # Inicializar lista de resultados
        resultado = []

        # Adicionar as partes
        for parte in partes:
            if parte:
                resultado.append(parte.strip())

        return resultado

    def dividir_string_ref_cliente(self,texto):
        # Dividir a string quando aparece  de 'Ref\. Cliente'
        partes = re.split(r'(Ref\. Cliente)', texto)

        # Inicializar lista de resultados
        resultado = []

        # Adicionar as partes, cuidando para não adicionar strings vazias
        for parte in partes:
            if parte:
                resultado.append(parte.strip())

        return resultado

    def dividir_string_pr_unitario(texto):
        # Dividir a string quando aparecer de 'Pr. Unitário'
        partes = re.split(r'(Pr\. Unitário)', texto)

        # Inicializar lista de resultados
        resultado = []

        for parte in partes:
            if parte == 'Pr. Unitário':
                resultado.append(parte)
            else:
                sub_partes = re.split(r'\s+', parte.strip())
                for sub_parte in sub_partes:
                    if sub_parte:
                        resultado.append(sub_parte)
        return resultado

    def dividir_string_ORD_QTY_QTY_SUP(self,s):
        # Expressão regular para encontrar os padrões 'ORD QTY' e 'QTY SUP'
        padrao = r'\b(ORD QTY|QTY SUP)\b'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja 'ORD QTY' ou 'QTY SUP'
        resultado = []
        for parte in partes:
            if parte in ['ORD QTY', 'QTY SUP']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_v_caja_codigo_barras(self,s):
        # Expressão regular para encontrar os padrões 'V.Caja' e 'Código de Barras'
        padrao = r'(V\.Caja|Código de barras)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja um dos padrões
        resultado = []
        for parte in partes:
            if parte in ['V.Caja', 'Código de barras']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_pçunit_desconto(self,s):
        # Expressão regular para encontrar os padrões 'Pç.Unitário' e 'Desconto %'
        padrao = r'(Pç\.Unitário|Desconto %)'

        # Dividir a string com base no padrão, com a preservação dos delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja um dos padrões
        resultado = []
        for parte in partes:
            if parte in ['Pç.Unitário', 'Desconto %']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_pçunit_desconto_sem_sedilha(self,s):
        # Expressão regular para encontrar os padrões 'Pç.Unitário' e 'Desconto %'
        padrao = r'(Pc\.Unitário|Desconto %)'

        # Dividir a string com base no padrão, com a preservação dos delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja um dos padrões
        resultado = []
        for parte in partes:
            if parte in ['Pc.Unitário', 'Desconto %']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_validade_do_lote(self,s):
        # Expressão regular para encontrar o padrão 'Validade do Lote'
        padrao = r'(Validade do Lote)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja 'Validade do Lote'
        resultado = []
        for parte in partes:
            if parte == 'Validade do Lote':
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_validade_do_lote_minusc(self,s):
        # Expressão regular para encontrar o padrão 'Validade do Lote'
        padrao = r'(Validade do lote)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja 'Validade do Lote'
        resultado = []
        for parte in partes:
            if parte == 'Validade do lote':
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_preco_unit_ponto(self,s):
        # Expressão regular para encontrar os padrões 'Preço Unit.' e 'Tx. IVA'
        padrao = r'(Preço Unit\.|Tx\. IVA)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja um dos padrões
        resultado = []
        for parte in partes:
            if parte in ['Preço Unit.', 'Tx. IVA']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_cant_de_entrega(self,s):
        # Expressão regular para encontrar os padrões 'Preço Unit.', 'Tx. IVA', e 'Cant. de entrega'
        padrao = r'(Cant\. de entrega)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja um dos padrões
        resultado = []
        for parte in partes:
            if parte in ['Cant. de entrega']:
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_id_mat_ponto(self,s):
        # Expressão regular para encontrar o padrão 'ID Mat.'
        padrao = r'(ID Mat\.)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja 'ID Mat.'
        resultado = []
        for parte in partes:
            if parte == 'ID Mat.':
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def dividir_string_preco_venda_pt50088(self,s):
        # Expressão regular para encontrar o padrão 'Preço Venda'
        padrao = r'(Preço Venda)'

        # Dividir a string com base no padrão, preservando os delimitadores
        partes = re.split(padrao, s)

        # Dividir cada parte da string que não seja 'Preço Venda'
        resultado = []
        for parte in partes:
            if parte == 'Preço Venda':
                resultado.append(parte)
            else:
                resultado.extend(parte.split())

        return resultado

    def split_string_dpdo(self,s):
        # Regex para separar as palavras e manter as pontuações junto delas
        pattern = r':QTE CDEE|P\.U\. H\.T|DEJA LIV|IRST|A LI|QTE LIVR|MONTANT HT|[;.:,!?]+|\S+'
        parts = re.findall(pattern, s)
        return parts

    def join_phrases_and_punctuation(self,words):
        result = []
        i = 0

        while i < len(words):
            word = words[i]
            next_word = words[i + 1] if i + 1 < len(words) else ""

            # Junta as combinações específicas ou palavras com pontuações
            if (word == ':QTE' and next_word == 'CDEE') or (word == 'P.U.' and next_word == 'H.T'):
                combined_word = word + " " + next_word
                result.append(combined_word)
                i += 2  # Avança para a próxima palavra após a que já foi combinada
            elif re.match(r'^[:;,.!]+$', word) and next_word:  # Junta as pontuações no começo
                combined_word = word + next_word
                result.append(combined_word)
                i += 2
            elif not re.match(r'^[:;,.!]+$', word):  # Ignora as pontuações solitárias
                result.append(word)
                i += 1
            else:
                i += 1  # Ignora as pontuações no fim da lista

        return result

    def run(self,string):
        if '|' in string:
            palavras = string.split('|')
        elif './' in string or 'Ref.Cli.' in string or 'Qtd:' in string:
            palavras = string.split(' ')
        elif 'NB PIECES' in string:
            palavras = self.transform_string_to_custom_list(string)
        elif 'Preço Venda' in string:
            palavras = self.transform_string_to_custom_list_preco_venda(string)
            if len(palavras) == 1:
                palavras = self.dividir_string_preco_venda_pt50088(string)
        elif 'Preço Liquido' in string and 'Valor Liquido' in string:
            palavras = self.transform_string_to_custom_list_preco_liquido(string)
        elif 'Pattern no' in string:
            palavras = self.transform_string_to_custom_list_Pattern_no(string)
        elif 'Preço Unitário' in string:
            palavras = self.dividir_string_preco_unitario(string)
        elif 'Ref. Cliente' in string:
            palavras = self.dividir_string_ref_cliente(string)
        elif 'Pr. Unitário' in string:
            palavras = self.dividir_string_pr_unitario(string)
        elif 'ORD QTY' in string or 'QTY SUP' in string:
            palavras = self.dividir_string_ORD_QTY_QTY_SUP(string)
        elif 'V.Caja' in string or 'Código de barras' in string:
            palavras = self.dividir_string_v_caja_codigo_barras(string)
        elif 'Pç.Unitário' in string:
            palavras = self.dividir_string_pçunit_desconto(string)
        elif 'Pc.Unitário' in string:
            palavras = self.dividir_string_pçunit_desconto_sem_sedilha(string)
        elif 'Validade do lote' in string:
            palavras = self.dividir_string_validade_do_lote_minusc(string)
        elif 'Preço Unit.' in string:
            palavras = self.dividir_string_preco_unit_ponto(string)
        elif 'Cant. de entrega' in string:
            palavras = self.dividir_string_cant_de_entrega(string)
        elif 'ID Mat.' in string:
            palavras = self.dividir_string_id_mat_ponto(string)
        elif 'QTE CDEE' in string:
            coisas_separadas = self.split_string_dpdo(string)
            palavras = self.join_phrases_and_punctuation(coisas_separadas)
        else:
            palavras = self.split_string(string)

        return palavras